# 单入口与中央大脑

> 内部端口繁杂，但**对用户只给一个简单明晰的入口**；用户需求由**中央大脑**解析并分发到对应处理端口，用户只关心需求，其余均为内部实现。

---

## 一、原则

| 对用户/助理侧 | 对主仓内部 |
|---------------|------------|
| **一个入口**：只需调用一个 API（如 `POST /v1/ask`），传入「用户说什么 / 想要什么」 | **多能力端口**：简历解析、职位匹配、匹配解释、诗人/诗词推荐、征信查询、MBTI、人才验证等，各自独立服务或模块 |
| **只关心需求**：不关心「该调哪个端口、哪个路径」 | **中央大脑**：根据意图解析结果，把请求转发到对应端口，并聚合返回 |
| **统一响应**：无论背后走了哪几条内部链路，对外返回格式一致、可理解 | **内部实现可替换**：端口地址、实现语言、部署方式可随版本调整，对外契约不变 |

---

## 二、请求流（示意）

```
用户 / 助理
    │
    │  POST /v1/ask  { "message": "帮我看看有没有适合我的职位", "context": { "user_id": "...", "session_id": "..." } }
    ▼
┌─────────────────────────────────────────────────────────┐
│  主仓 · 单入口 (如 Tatha API)                             │
│  ┌───────────────────────────────────────────────────┐  │
│  │  中央大脑                                           │  │
│  │  · 意图解析（求职/陪伴/诗人/验证/…）                  │  │
│  │  · 路由到内部端口                                    │  │
│  │  · 聚合结果、统一封装返回                             │  │
│  └───────────────────────────────────────────────────┘  │
│         │              │              │              │   │
│         ▼              ▼              ▼              ▼   │
│  [解析服务]    [匹配服务]    [诗人 RAG]   [征信/MBTI]  …   │
└─────────────────────────────────────────────────────────┘
    │
    ▼
  统一 JSON 响应  { "intent": "...", "result": { ... }, "suggestions": [...] }
```

---

## 三、对外契约（建议）

- **唯一必记入口**：`POST /v1/ask`（或 `/v1/request`），请求体包含用户输入与可选上下文；可选再提供 `GET /health` 用于探活。
- **内部端口**：不对外暴露路径；仅主仓内部配置（如解析服务 URL、匹配服务 URL、诗人 RAG 服务 URL），中央大脑通过配置或服务发现调用。
- **启动与运维**：对外只需保证「一个 host + 一个端口」可达；内部可多进程、多端口、多机，由主仓或网关统一汇聚。

---

## 四、在 Tatha 中的落地

- **api 层**：实现单一路由 `POST /v1/ask`，请求进入后先走**意图解析**（可用 LiteLLM + PydanticAI 或 Marvin 做「用户消息 → intent + slots」），再根据 intent 调用内部能力（解析、匹配、诗人推荐等），最后统一封装为同一响应结构。
- **内部能力**：以模块或内部 HTTP 形式存在（如 `core.parse_resume`、`retrieval.match_jobs`、`retrieval.poetry_recommend`），**不**直接暴露为对外路径。
- **配置**：内部各能力端口/模块的地址或开关放在 `.env` 或配置中心，便于在不同环境切换或关闭某能力而不影响「单入口」契约。

详见 [设计说明_九库与Tatha.md](设计说明_九库与Tatha.md)；与收敛文档的对应见 [开发收敛与可交付路线图 §7.3](../JobFirst/docs/开发收敛与可交付路线图.md)。

---

## 五、内部微服务组织建议

内部「多能力端口」可以有两种形态：**同仓模块**（单进程内函数/模块调用）或 **真实微服务**（多进程/多端口，由中央大脑或网关转发）。建议先收敛、再按需拆分；若拆成微服务，**优先采用自主可控的 gozervi（Go）或 zervi-rust（rust-gozervi）** 做网关与认证层，AI 侧保留 Python（Tatha）；二者对 Python AI 同样友好，选型见 §5.4。

### 5.1 建议：先同仓模块，再按需拆微服务

| 阶段 | 做法 | 说明 |
|------|------|------|
| **V0 / 当前** | 内部能力以 **Tatha 主仓内模块** 存在（`core` / `ingest` / `agents` / `retrieval`） | 中央大脑在同一进程内通过函数或内部接口分发，无跨进程调用；部署简单、排查方便，适合先跑通单入口与意图解析。 |
| **按需拆分** | 当某能力需独立扩缩容、独立部署或与现有 Go 服务复用时，再拆成**独立服务** | 解析、匹配、诗人 RAG 等 AI 密集仍建议 **Python**；认证、网关、转发等建议 **gozervi（Go）**，见下。 |

### 5.2 若拆微服务：推荐 gozervi / zervi-rust + Python 分工

| 层次 | 推荐技术 | 理由 |
|------|----------|------|
| **单入口网关 / 认证 / 转发** | **gozervi（Go）或 zervi-rust（Rust）** | 自主可控；JWT、OAuth2、RBAC、与现有 DB/Redis 对接；适合「对外唯一端口 + 鉴权 + 将 /v1/ask 转发到 Tatha」。二者对 Python 侧等价，选型见 §5.4。 |
| **中央大脑 + AI 能力** | **Tatha 主仓（Python）** | 意图解析、简历解析、匹配、诗人 RAG 等强依赖 LiteLLM、LlamaIndex、九库；保持 Python 可复用现有代码与生态。 |
| **征信 / MBTI / 人才验证** | **现有各仓（Go 或 Python）** | 可保留为独立服务，由中央大脑或网关通过 HTTP 调用；接口契约统一即可。 |

**两种常见拓扑**：

- **A）gozervi 或 zervi-rust 做网关，Tatha 做中央大脑**  
  用户请求 → **网关**（gozervi 或 zervi-rust：单入口、鉴权）→ 转发 `POST /v1/ask` 到 **Tatha 主仓**（Python）→ Tatha 内意图解析并调用内部模块或下游微服务 → 统一返回；征信/MBTI 等由 Tatha 或网关按配置转发。

- **B）Tatha 单进程同时做网关与中央大脑**  
  用户请求 → **Tatha 主仓**（Python，单端口）→ 内嵌鉴权（或调 gozervi/zervi-rust 校验 token）→ 意图解析与分发；适合 V0 或资源有限时，后续再在前侧加网关。

### 5.3 其他框架（备选）

| 方案 | 适用场景 |
|------|----------|
| **纯 Python 微服务** | 各能力均为 FastAPI 子应用，由同一 Python 网关或 Nginx 做路由；与 Tatha 同语言，易共享类型与工具，但认证与 Zervigo 对接需自建或复用 gozervi 的 HTTP 接口。 |
| **Kong / Nginx / Traefik** | 仅做反向代理与负载均衡时可用；鉴权与业务路由若希望自主可控，仍建议 gozervi 或 Tatha 内实现。 |
| **K8s / Docker Compose** | 部署与编排层；微服务本身仍建议按 5.2 选型（gozervi 网关 + Python 能力）。 |

**结论**：内部微服务组织优先 **自主可控的 gozervi 或 zervi-rust** 承担「单入口、认证、转发」；AI 与中央大脑留在 **Tatha（Python）**；先以同仓模块收敛，再按需拆成独立进程。选型对比见下 5.4。

### 5.4 gozervi（Go）与 zervi-rust（rust-gozervi）对比与选型

两者均为自主可控的 zervi 体系：**gozervi** 为 Go 版（与 Zervigo 同栈），**zervi-rust** 即 **rust-gozervi**（imartOS 下 Rust 版，JWT/OAuth2/RBAC、Tauri、可选 Axum/Actix-web HTTP 服务）。网关层二选一即可，对**后端 Python AI（Tatha）** 的友好程度一致。

#### 对 Python AI 开发的友好程度：**等价**

| 维度 | gozervi（Go） | zervi-rust（Rust） |
|------|----------------|---------------------|
| **与 Tatha 的边界** | HTTP：网关校验 token 后转发请求到 Tatha（Python），或透传 Header | 同上，HTTP 转发/透传 |
| **Python 侧感知** | 无差异：Tatha 只暴露 `POST /v1/ask` 等 REST，谁转发过来都一样 | 无差异 |
| **认证对接** | 网关校验 JWT，可把 `user_id` 等注入 Header 再转 Tatha；或 Tatha 调网关校验 | 同上，与 rust-gozervi 共享 DB/Redis，API 兼容 |
| **部署** | 网关与 Tatha 可同机或分机，仅需配置 Tatha 的 URL | 同上 |

**结论**：对 Python AI 开发而言，**两者谁更友好没有区别**——都是「前面多一层 HTTP 网关」，Tatha 只关心契约（请求/响应格式、Header 中的身份信息）。选型应主要看**栈统一、现有投入与运维**，见下。

#### 选型建议

| 倾向 | 更合适的方案 | 理由 |
|------|--------------|------|
| **前端/网关层统一用 Rust** | **zervi-rust（rust-gozervi）** | 助理侧已是 ZeroClaw（Rust）+ rust-gozervi；网关也用 Rust 则「单入口 + 认证 + 助理」全在 Rust，仅 Tatha 为 Python，语言栈更简单（Rust + Python 两套），且 Rust 单二进制、无运行时，适合树莓派/边缘。 |
| **与现有 Zervigo/生产 Go 体系一致** | **gozervi（Go）** | 若 Zervigo 与现网网关已是 Go，用 gozervi 可复用既有运维、监控与代码；Go 编译与迭代速度快，团队若更熟 Go 可优先。 |
| **希望网关与助理同进程/同二进制** | **zervi-rust** | rust-gozervi 可提供 HTTP 服务；若将来把「网关 + 本地助理」打成一个 Rust 二进制（如内嵌 ZeroClaw 或反向代理到 ZeroClaw），部署更简单。 |
| **暂时不引入网关** | **Tatha 单进程** | V0 可仍由 Tatha 直接对外，内嵌鉴权或调 gozervi/zervi-rust 的校验接口；待流量与安全需求上来再前挂网关。 |

**简要结论**：  
- **对 Python AI**：gozervi 与 zervi-rust **一样友好**，都是 HTTP 边界，Tatha 无需改代码。  
- **选型**：若希望**整体栈向 Rust 收敛**（助理 + 网关一体、边缘部署），优先 **zervi-rust**；若**强依赖现有 Go 与 Zervigo 生产**，优先 **gozervi**。两者也可并存（例如生产用 gozervi，本地/边缘用 zervi-rust 做代理），只要与 Tatha 的接口契约统一即可。
